
    fn load2<P: AsRef<Path>>(
        device: &wgpu::Device,
        queue: &wgpu::Queue,
        layout: &wgpu::BindGroupLayout,
        path: P,
    ) -> Result<Self, failure::Error> {
        let (obj_models, obj_materials) = tobj::load_obj(path.as_ref(), true)?;

        // We're assuming that the texture files are stored with the obj file
        let containing_folder = path.as_ref().parent().unwrap();

        let mut materials = Vec::new();

        for mat in obj_materials {

            let diffuse_path = mat.diffuse_texture;
            let copy_diffuse_path = diffuse_path.clone();

            let result = match diffuse_path.is_empty() {
                false => Texture::load(&device, queue, containing_folder.join(diffuse_path)),
                true => Texture::from_color(&device, queue, [1u8, 1u8, 1u8, 1u8], None),
            };

            let diffuse_texture = result
                .ok()
                .unwrap();

            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                layout,
                entries: &[
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::TextureView(&diffuse_texture.view),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Sampler(&diffuse_texture.sampler),
                    },
                ],
                label: None,
            });

            let color = [mat.diffuse[0], mat.diffuse[1], mat.diffuse[2], 1.0];

            materials.push(Material {
                name: mat.name,
                diffuse_texture,
                bind_group,
                color
            });
            //command_buffers.push(cmds);
        }

        let mut meshes = Vec::new();
        for mut m in obj_models {
            let mut vertices = Vec::new();

            //println!("pos len = {}", m.mesh.positions.len());
            //println!("tex_coords len = {}", m.mesh.texcoords.len());
            //println!("normal len = {}", m.mesh.normals.len());

            for i in 0..m.mesh.positions.len() / 3 {

                let tex_coords = if (i * 2 + 1) < m.mesh.texcoords.len(){
                    [m.mesh.texcoords[i * 2], m.mesh.texcoords[i * 2 + 1]]
                }
                else{
                    [i as f32 % 2f32, (i / 2) as f32 % 2f32]
                };

                let normal = if (i * 3 + 2) < m.mesh.normals.len(){
                    [m.mesh.normals[i * 3], m.mesh.normals[i * 3 + 1], m.mesh.normals[i * 3 + 2]]
                }
                else{
                    [0.0, 0.0, 0.0]
                };

                let color = if let Some(material_id) = m.mesh.material_id {
                    materials.get(material_id).unwrap().color
                }
                else{
                    [1.0, 1.0, 1.0, 1.0]
                };

                vertices.push(ModelVertex {
                    position: [
                        m.mesh.positions[i * 3],
                        m.mesh.positions[i * 3 + 1],
                        m.mesh.positions[i * 3 + 2],
                    ],
                    tex_coords,
                    normal,
                    color
                });
            }

            let vertex_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
                label: Some(&format!("{:?} Vertex Buffer", path.as_ref())),
                contents: bytemuck::cast_slice(&vertices),
                usage: wgpu::BufferUsage::VERTEX,
            });
            let index_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
                label: Some(&format!("{:?} Index Buffer", path.as_ref())),
                contents: bytemuck::cast_slice(&m.mesh.indices),
                usage: wgpu::BufferUsage::INDEX,
            });

            meshes.push(Mesh {
                name: m.name,
                vertex_buffer,
                index_buffer,
                num_elements: m.mesh.indices.len() as u32,
                material: m.mesh.material_id.unwrap_or(0),
            });
        }

        Ok(Self { meshes, materials })
    }